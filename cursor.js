import{renderCursor as e}from"./utils/renderTools.js";import{createEventSource as t}from"./utils/eventSource.js";import{extractPointerOrTouchOffset as s}from"./utils/eventUtils.js";function n(e,t,s){let n=0;do{if(s<e[n])break;n++}while(n<e[n]);const i=e[n-1],r=t[n-1],o=e[n];return{x:s,y:(t[n]-r)/(o-i)*(s-i)+r}}export function createCursor(i){let r;const o={x:null,y:null,intersections:[],isTracking:!1},{addEventListener:a,removeEventListener:c,dispatch:l}=t(),u=()=>{if(!r.charts||0===r.charts.length||[o.x,o.y].some(e=>!Number.isFinite(e)))return void(o.intersections=[]);const{x:e}=r.charts,t=r.xscale.rtod(o.x);o.intersections=r.charts.y.filter(e=>e.shouldRender).map(({name:s,values:i,style:r})=>({...n(e,i,t),name:s,style:r})).filter(e=>Number.isFinite(e.x)&&Number.isFinite(e.y))},m=i.getContext("2d");let d;const v=()=>{m.clearRect(0,0,m.canvas.width,m.canvas.height),m.save();const{scale:t}=r;m.scale(t,t),e(m,{position:E(),intersections:L(),xscale:r.xscale,yscale:r.yscale,style:r.style}),m.restore(),d()};d=(()=>window.requestAnimationFrame(v));const h=e=>{const{x:t,y:n}=s(e),i=r.xscale.range(),a=i[0]>i[1]?i[1]:i[0],c=i[0]<i[1]?i[1]:i[0];o.x=Math.min(c,Math.max(a,t/r.scale)),o.y=n/r.scale,u(),l("position",{areaX:o.x,areaY:o.y,x:t,y:n})},x=h,y=({isTouch:e})=>t=>{o.isTracking||(o.isTracking=!0,h(t),i.addEventListener(e?"touchmove":"mousemove",x))},g=({isTouch:e})=>()=>{o.isTracking=!1,i.removeEventListener(e?"touchmove":"mousemove",x)};i.addEventListener("touchstart",y({isTouch:!0})),i.addEventListener("mouseover",y({isTouch:!1})),i.addEventListener("touchend",g),i.addEventListener("mousedown",g);const E=()=>({x:o.x,y:o.y}),L=()=>o.intersections;return{getPosition:E,getIntersections:L,recalculateIntersections:u,start(){d()},setProps(e){r={...r,...e}},addEventListener:a,removeEventListener:c}}